<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Functional Programming with Elixir (and Ruby)</title>

    <meta name="description" content="A programming talk presented at YEGRB on December 16th">
    <meta name="author" content="Nathan Feaver">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/agilestyle.css" id="theme">
    <link rel="stylesheet" href="css/addon/elixir.css" id="addon-elixir">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <!--[if lt IE 9]>
      <script src="lib/js/html5shiv.js"></script>
      <![endif]-->
  </head>

  <body>

    <div class="reveal">
      <div id="logo_container">
        <img src="/images/AgileStyle-Logo-white-200x40.png">
      </div>

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>You Should Try Elixir</h1>
          <p>
          <h3>Nathan Feaver, Senior Developer @ AgileStyle</h3>
          </p>
        </section>

        <section>
          <section>
            <h2>Why Should You Try Elixir?</h2>
          </section>
          <section>
            <h2>Other People Are Doing It</h2>
          </section>
          <section class='quotation'>
            <blockquote><div class='ldquo'>&ldquo;</div>Elixir has changed the way I think about programming.  Not just in terms of "Oh, its a functional language", it's actually changed my conception of what it means to program.<span class="author">~ Dave Thomas</span></blockquote>
          </section>
          <section class='quotation'>
            <blockquote><div class='ldquo'>&ldquo;</div>I want to long term use [Elixir and the Phoenix Framework] to replace all of my client work and everything I want to build personally<span class="author">~ Chris McCord</span></blockquote>
          </section>
          <section class='quotation'>
            <blockquote><div class='ldquo'>&ldquo;</div>Programming in Erlang sucks. Elixir is everything good about Erlang and none — almost none — of the bad.<span class="author">~ Devin Torres</span></blockquote>
            <aside class='notes'>
              Devin Torres is a well-known contributor in the erlang open source community.
            </aside>
          </section>
          <section>
            <h3>Don't forget José Valim</h3>
          </section>
        </section>

        <section>
          <section>
            <h2>Why Should You Try Elixir?</h2>
          </section>
          <section>
            <h2>It's Built on the Erlang Virtual Machine</h2>
          </section>
          <section>
            <h2>Erlang</h2>
            <p>Erlang was originally developed in 1986 by Ericsson for telephony applications to support highly concurrent systems</p>
            <ul>
              <li>Mature Language/Tools/Community</li>
              <li>Concurrency (OTP)</li>
              <li>Distributed (OTP)</li>
              <li>Fault Tolerant</li>
              <li>Hot code swapping</li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h2>Why Should You Try Elixir?</h2>
          </section>
          <section>
            <h2>It's Easy to Get Started</h2>
          </section>
          <section>
            <h2>Great Toolset for a Young Language</h2>
            <ul>
              <li><code>brew install elixir</code></li>
              <li>Rake ~&gt; Mix</li>
              <li>Bundler ~&gt; Hex</li>
              <li>IRb ~&gt; IEx</li>
              <li>RSpec ~&gt; ExUnit</li>
            </ul>
          </section>
          <section>
            <h2>Ruby-Inspired Syntax</h2>
            <pre><code data-trim class='elixir'>
defmodule Recursion do
  def print_multiple_times(msg, n) when n &lt;= 1 do
    IO.puts msg
  end

  def print_multiple_times(msg, n) do
    IO.puts msg
    print_multiple_times(msg, n - 1)
  end
end
            </code></pre>
          </section>
          <section>
            <h2>Learning Resources</h2>
            <ul>
              <li><a href="http://elixir-lang.org/getting_started/1.html">elixir-lang.org/getting_started/1.html</a></li>
              <li><cite>Programming Elixir</cite> – Dave Thomas</li>
              <li><a href="http://exercism.io/">Exercism.io</a></li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h2>Why Should You Try Elixir?</h2>
          </section>
          <section>
            <h2>Curiosity About Functional Languages or Concurrency</h2>
          </section>
          <section>
            <h2>Metaprogramming</h2>
            <aside class="notes">Built from the beginning with a focus on metaprogramming using macros</aside>
          </section>
          <section>
            <h2>The Phoenix Web Framework</h2>
          </section>
          <section>
            <h2>Jobs!</h2>
            <small>But not in Edmonton</small>
          </section>
        </section>

        <section>
          <section>
            <h2>Learning Some Elixir</h2>
            <h4>Let's see some action!</h2>
          </section>
          <section>
            <h2>Functions are First Class Objects</h2>
            <pre><code data-trim class='iex'>
iex> add = fn a, b -> a + b end
#Function<12.71889879/2 in :erl_eval.expr/5>
iex> add.( 1, 2 )
3
iex> shorthand_add = &( &1 + &2 )
&:erlang.+/2
iex> Enum.map([ 1,2,3 ], &( &1 * 2 ))
[2, 4, 6]
            </code></pre>
            <pre><code data-trim class='iex'>
defmodule MyApp do
  def times_2( n ) do
    n * 2
  end
end
ex(16)> Enum.map([ 1,2,3 ], &MyApp.times_2/1)
[2, 4, 6]
            </code></pre>
          </section>
          <section>
            <h2>Immutability</h2>
          </section>
          <section>
            <h2>Pattern Matching</h2>
            <pre><code data-trim class='iex'>
iex> a = [ 1,2,3 ]
iex> b = [[ 1,2,3 ]]
iex> [c] = [[ 1,2,3 ]]
iex> a == c
true
iex> [ x,y,z ] = [ 1,2,3 ]
iex> z
3
iex> "Elixir " &lt;&gt; rest = "Elixir Rocks!"
iex> rest
"Rocks!"
            </code></pre>
            <pre><code data-trim class='elixir'>
defmodule MyApp do
  def callback(:ok, data) do
    # success
  end

  def callback(:error, data) do
    # handle failure
  end
end
            </code></pre>
            <aside class='notes'>
              pervasive
              You're not assigning 1 to a, you're challenging elixir to find a way to make that true
            </aside>
          </section>
          <section>
            <h2>Concurrency/Distribution</h2>
          </section>
          <section>
            <h2>Head | Tail Recursion</h2>
          </section>
        </section>

        <section>
          <section>
            <h2>Coming Back to Ruby</h2>
            <h4>Can I apply this in my day job?</h4>
          </section>
          <section>
            <h2>Updating Records Functionally?</h2>
            <pre><code data-trim class='ruby'>
it 'releases one invite credit when it is withdrawn' do
  sender = @invite.sender
  expect{ @invite.withdraw; sender.reload }.
    to change{ sender.available_invite_credits.length }.
    by(1)
end
            </code></pre>
            <pre><code data-trim class='ruby'>
it 'releases one invite credit when it is withdrawn' do
  sender = @invite.sender
  expect{ @invite.withdraw }.
    to change{ User.available_invite_credits(sender.id).length }.
    by(1)
end
            </code></pre>
          </section>
          <section>
            <h2>Another Attempt</h2>
            <pre><code data-trim class='ruby'>
# find the author counts
author_counts = []
author_counts_index = -1
current_author = ''
for i in 0...commits.length
  commit = commits[i]
  if commit.author == current_author
    author_counts[author_counts_index][1] += 1
  else
    current_author = commit.author
    author_counts &lt;&lt; [commit.author, 1]
    author_counts_index += 1
  end
end
            </code></pre>
            <pre><code data-trim class='ruby'>
commits.sort_by do |commit|
  commit.author
end.
  chunk do |commit|
    commit.author
  end.
    each do |author, author_commits|
      puts "#{author} has #{author_commits.count} commits"
    end
            </code></pre>
          </section>
          <section>
            <h2>Ruby is an OO Language, Default to OO Idioms</h2>
            <ul>
              <li>Use functional style blocks</li>
              <li>Bottom-up versus Top-down</li>
              <li>Tell Don't Ask</li>
              <li>Read POODR by Sandi Metz</li>
            </ul>
            <br/>
            <br/>
            <p>
              My approaches to some Ruby problems have probably changed in subtle ways.
              Learning Elixir has been fun and will help me learn other languages (and
              their strengths) faster. I'm probably also better prepared to
              use Proc objects, the Proc#curry method, and Enumerator::Lazy objects
              but directly practicing them would be even better (perhaps with katas).
            </p>
          </section>
        </section>

        <section>
          <h2>Getting Started with Elixir</h2>
          <ul>
            <li><code>brew install elixir</code></li>
            <li><a href="http://elixir-lang.org/">elixir-lang.org</a></li>
            <li><a href="http://exercism.io/">Exercism.io</a></li>
            <li><cite>Programming Elixir</cite> – Dave Thomas</li>
          </ul>
        </section>

        <section>
          <h1>THE END</h1>
          <h4>nathan@agilestyle.com</h4>
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
  controls: true,
  progress: true,
  history: true,
  center: true,

  theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
  transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

    // Parallax scrolling
    // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
    // parallaxBackgroundSize: '2100px 900px',

    // Optional libraries used to extend on reveal.js
  dependencies: [
  { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
  { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
  { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
});

    </script>

  </body>
</html>
